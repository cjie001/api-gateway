
#user  nobody;
worker_processes  auto;
worker_cpu_affinity auto;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
error_log  logs/error.log  info;
#error_log logs/error.log   crit;           # 只记录严重错误

# 每个worker能处理的最大连接数(理论最大值=worker_processes*worker_connections)
# 需要 root 权限, 可由 root 配置 /etc/security/limits.conf
# worker_rlimit_nofile 1000000;             # 提高worker进程的文件描述符限制

pid .nginx.pid;                           # 与日志目录分开, 避免误删

events {
    #worker_connections 102400;             # 每个worker进程能处理的最大连接数
    worker_connections 65535;               # 生产环境可提高该值
    use epoll;                              # Linux高性能事件模型
    multi_accept on;                        # 一次接受所有新连接
    accept_mutex off;                       # 高负载时关闭互斥锁可提高性能
}

http {
    include       mime.types;

    # 声明变量（必须放在 http 块顶部）
    variables_hash_max_size 2048;
    variables_hash_bucket_size 128;

    # 定义自定义变量
    map $uri $original_uri {
        default "";
        ~*    "";  # 强制启用哈希存储
    }

    real_ip_header X-Real-IP;
    set_real_ip_from 127.0.0.1;
    set_real_ip_from unix:;

    more_set_headers 'Server: C-API Gateway';

    lua_code_cache on;

    # 日志优化
    # 如果需要日志，可以使用以下缓冲配置
    access_log logs/access.log combined buffer=64k flush=5m;
    # access_log off;  # 百万连接时建议关闭访问日志，或使用缓冲
    log_format main '$remote_addr\t$http_x_forwarded_for\t$time_iso8601\t$scheme://$http_host\t$request\t$request_length\t'
    '$http_referer\t$http_user_agent\t$connection_requests\t$upstream_cache_status\t$status\t'
    '$request_time\t$upstream_response_time\t$bytes_sent\t$body_bytes_sent\t$server_name\t'
    '$upstream_addr\t$upstream_status\t$request_id\t';

    log_format trace_log '$remote_addr - $upstream_addr [$time_local] '
                         '"$request" $status $body_bytes_sent '
                         '"$http_referer" "$http_user_agent" '
                         'tid=$trace_id rt=$request_time route_key=$route_key '
                         'route=$route_id rewrite="$original_uri -> $uri"';

    #access_log  logs/access.log  main;

    # 基础性能优化
    sendfile on;                # 启用高效文件传输模式
    tcp_nopush on;              # 仅在sendfile开启时有效，合并数据包减少发送次数
    tcp_nodelay on;             # 禁用Nagle算法，提高实时性

    keepalive_timeout  65;      # 客户端连接保持时间
    keepalive_requests 10000;   # 单个keepalive连接的最大请求数

    # 客户端请求体缓冲区大小
    client_body_buffer_size 128k;
    client_header_buffer_size 4k;
    client_max_body_size 8m;
    large_client_header_buffers 4 16k;

    # MIME类型缓存
    open_file_cache max=10000 inactive=20s;
    open_file_cache_valid 30s;
    open_file_cache_min_uses 2;
    open_file_cache_errors on;


    # 开启gzip压缩
    gzip on;
    gzip_min_length 1k;
    gzip_comp_level 2;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;
 
     # 连接限制（压测时关闭）
    # limit_conn_zone $binary_remote_addr zone=addr:10m;
    # limit_conn addr 2000;  # 单个IP最大连接数
     # 定义全局限流共享内存区（10MB内存，每秒5000请求）
    # limit_req_zone "" zone=global_rate:10m rate=5000r/s;

    lua_package_path "$prefix/lua/?.lua;;";
    lua_shared_dict uri_rules           2m;   # uri规则
    lua_shared_dict route_key_maps      12m;  # route_key和route_id映射
    lua_shared_dict route_configs       10m;  # route_id->路由规则
    lua_shared_dict upstreams           5m;   # upstreams配置
    lua_shared_dict limit_shared_dict   20m;  # 限流计数器
    lua_shared_dict circuit_breaker     10m;  # 熔断状态存储
    lua_shared_dict delay_dict          1m;   # mock延时参数
    lua_shared_dict token_ips           1m;   # Token-IP绑定关系
    lua_shared_dict rules_api_url       1m;   # 后台规则服务地址变量


    init_by_lua_block {
        -- 加载UUID库
        local resty_uuid = require "resty.jit-uuid"
        resty_uuid.seed()  -- 初始化随机种子

        -- 创建全局UUID生成函数
        _G.generate_trace_id = function()
            -- 或者生成v1 UUID (基于时间戳+MAC地址，性能更好)
            return resty_uuid.generate_v4()
        end

        require "router.init"  -- 初始化路由规则
    }

    # 动态 upstream 即使节点是动态也必须存在（赣州银行未使用）
    upstream dynamic_backend {
        server 0.0.0.1;  # 假地址

        balancer_by_lua_block {
            require("router.balancer").route()
        }

        # 长连接优化核心参数
        keepalive 200;
        keepalive_timeout 300s;
        keepalive_requests 10000;
    }

    # 管理端口
    server {
        listen       9100;
        server_name  localhost;
        default_type application/json;

        # 接口认证
        access_by_lua_block {
            local auth = require "router.auth"
            if not auth.check() then
                ngx.say('{"code": 403, "message": "Admin API requires authentication"}')
                return ngx.exit(403)
            end
        }

        # 状态监控接口
        location = /admin/status {
            allow 127.0.0.1;   # 只允许本地访问
            allow 10.0.0.0/8;  # 内部网络
            deny all;

            content_by_lua_block {
                local cjson = require "cjson.safe"
                local status = require "router.status"
                local args = ngx.req.get_uri_args()
                
                -- 参数处理
                -- local query_args = {
                --    merchant_map = args.merchant_map ~= nil,  -- 只要存在参数即触发
                --    routes = args.routes ~= nil
                -- }
                -- local resp = status.query(query_args)
                -- ngx.say(cjson.encode(resp))

                ngx.say(cjson.encode(status.query(args)))
            }
        }
        location = /admin/health {
            allow 127.0.0.1;   # 只允许本地访问
            allow 10.0.0.0/8;  # 内部网络, 按需修改
            deny all;

            access_by_lua_block {
                local cjson = require "cjson.safe"
                local status = require "router.status"
                ngx.say(cjson.encode(status.health()))
            }
        }

        # 带接口认证的规则更新接口
        location = /admin/update_rules {
            # 支持两种更新方式
            content_by_lua_block {
                if ngx.req.get_method() == "POST" then
                    require("router.update").handle_post()
                else
                    require("router.update").sync_rules()
                    ngx.say("Manual sync triggered")
                end
            }
        }

        # Token管理接口（需访问控制）
        location = /admin/tokens {
            #allow 10.0.0.0/8;  # 限制管理接口访问
            allow 127.0.0.1;
            deny all;
            content_by_lua_file lua/router/token_admin.lua;
        }
    }

    # API Gateway 服务
    server {
        listen       9000;
        server_name  localhost;

        # 接口认证
        access_by_lua_block {
            local auth = require "router.auth"
            if not auth.check() then
                ngx.header["Content-Type"] = "application/json"
                ngx.say('{"code": 403, "message": "API requires authentication"}')
                return ngx.exit(403)
            end
        }

        set $backend_host '';
        set $backend_port '';

        # 匹配除/外的所有请求
        location ~* ^/.+$ {

            set $trace_id '';
            set $route_key '';
            set $route_id '';

            # 记录有 trace_id 的 api-access.log 日志
            access_log logs/api-access.log trace_log;
            # 应用限流（突发不超过5000请求）
            #limit_req zone=global_rate burst=5000 nodelay;

            access_by_lua_block {
                -- 生成TraceID
                local trace_id = generate_trace_id()

                -- 设置请求头 (符合W3C Trace Context标准)
                ngx.req.set_header("Tlogtraceid", trace_id)
                ngx.req.set_header("Tlogspanid", "0")
                ngx.req.set_header("Preivkapp", "C-API-Gateway")
                ngx.req.set_header("Preivkhost", ngx.var.hostname)
                ngx.req.set_header("Preip", ngx.var.server_addr)

                -- 设置变量供日志记录
                ngx.var.trace_id = trace_id

                require "router.access".handle()
            }

            rewrite_by_lua_block {
                -- 提前初始化变量
                ngx.var.original_uri = ngx.var.uri
            }

            # 连接控制（需匹配keepalive配置）
            proxy_http_version 1.1;
            proxy_set_header Connection "";
            proxy_set_header Host $host;

            # 超时参数（根据业务调整）
            proxy_connect_timeout 3s;
            proxy_send_timeout 10s;
            proxy_read_timeout 30s;

            # 失败重试策略（建议开启, 针对指定错误响应码开启）
            proxy_next_upstream error timeout http_500 http_502 http_503 http_504;
            proxy_next_upstream_timeout 2s;
            proxy_next_upstream_tries 2;

            # 启用动态配置
            proxy_pass http://dynamic_backend;
        }

    }

    # MockServer, 可去除
    server {
        listen       9001;
        server_name  localhost;

        default_type application/json;

        # 模拟从后台获取路由规则信息
        location = /mock/latest_rules {
            content_by_lua_block {
                require ("mock").mock_last_rules()
            }
        }

        # 匹配所有其他请求
        location ~ / {
            content_by_lua_block {
                require ("mock").mock_response()
            }
        }
    }

}
